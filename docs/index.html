<!doctype html><html lang="en"><head>  <meta charset="utf-8">  <title>Fileworthy</title>  <link rel="stylesheet" href="highlightjs/styles/github.css">  <script src="highlightjs/highlight.pack.js"></script>  <script>hljs.initHighlightingOnLoad();</script></head><body><h1 id="fileworthy">Fileworthy</h1>
<h2 id="introduction">Introduction</h2>
<ul>
<li>Fileworthy is intended to facilitate easy management of files and notes across many devices</li>
</ul>
<h3 id="goals-and-motivation">Goals and Motivation</h3>
<ul>
<li>My primary, and preferred workflow is editing my files off my <strong>local</strong> drive in <a href="https://neovim.io/">Neovim</a><ul>
<li>and I don&#39;t want this to change</li>
</ul>
</li>
<li>But I&#39;d also like to be able to view all my files and directories as a website<ul>
<li>especially when I&#39;m on the go</li>
<li>and with a small mobile device</li>
</ul>
</li>
<li>The website should basically be a simple reprentation of the contents of one or more directories</li>
<li>The notes would ideally be written in a markup language such as <a href="https://guides.github.com/features/mastering-markdown/">Markdown</a> so that:<ul>
<li>they can be easily transformed to other structured formats like HTML</li>
<li>easily edited with any text editor</li>
<li>easily manipulated by other tools<ul>
<li>as we&#39;re just dealing with <strong>plain text</strong></li>
</ul>
</li>
</ul>
</li>
<li>The website should also support<ul>
<li>editing of text files</li>
<li>managing binary files</li>
</ul>
</li>
<li>To keep the files on your local file-system and the website in sync<ul>
<li>consider using a 3rd-party app like <a href="https://syncthing.net">Syncthing</a></li>
</ul>
</li>
<li>Configuration should be optional, with sensible defaults chosen<ul>
<li>i.e. you shouldn&#39;t have to structure your files in any particular way</li>
<li>or include any special template files, etc.</li>
<li>and least of all, require any complex setup</li>
<li>though these options should be available if needed</li>
</ul>
</li>
</ul>
<h3 id="proposed-solution">Proposed Solution</h3>
<ul>
<li>Create an app that will display the contents of one or more directories as a regular website</li>
<li>Any file can be downloaded</li>
<li>If the browser natively supports the file format<ul>
<li>e.g. plain text, images, movies, etc.</li>
<li>it will render it as is</li>
<li>and an option to specify additional file formats as plain text so they can be viewed as such</li>
</ul>
</li>
<li>Markdown files will be transformed to HTML</li>
<li>Directories will simply be links to other pages</li>
<li>All files and directories can be further managed in the following ways:<ul>
<li>create new files/folders</li>
<li>upload files/folders</li>
<li>rename existing files/folders</li>
<li>edit text files through a web interface<ul>
<li>including source (Markdown) files from which an HTML page was generated</li>
</ul>
</li>
<li>delete files/folders</li>
</ul>
</li>
<li>Configuration files are optional<ul>
<li>i.e. use sensible defaults</li>
<li>of course this will be biased on <em>my</em> initial desires</li>
</ul>
</li>
</ul>
<h3 id="point-form-grammar">Point-Form Grammar</h3>
<ul>
<li>You might&#39;ve noticed that just about everything is written in point-form</li>
<li>I love point-form</li>
<li>I kind of view this as a sort of grammar<ul>
<li>where nested ideas are expressed as nested points</li>
<li>without the need to use much punctuation</li>
</ul>
</li>
<li>I&#39;m not sure if this is easier for casual, beginning-to-end reading<ul>
<li>but I find it a lot easier for scanning and browsing</li>
<li>and also to grasp complex ideas with lots of nesting</li>
</ul>
</li>
<li>I&#39;ve been taking all my notes in this form for over a decade<ul>
<li>and it&#39;s served me very well</li>
</ul>
</li>
<li>But you may very well find this form annoying<ul>
<li>so appologies in advance :)</li>
</ul>
</li>
</ul>
<h2 id="coding-choices">Coding Choices</h2>
<h3 id="language-environment">Language &amp; Environment</h3>
<ul>
<li>The app will be written in Common Lisp</li>
<li>I&#39;m primarily using <a href="http://www.sbcl.org/">SBCL</a><ul>
<li>but the code should work in most modern Common Lisp implementations</li>
<li>I&#39;m not explicitly choosing to depend on any features specific to SBCL<ul>
<li>but I&#39;m not sure the same is true for all libraries used</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="literate-programming">Literate Programming</h3>
<ul>
<li>This will also serve as my first foray into <a href="http://www.literateprogramming.com/knuthweb.pdf">literate programming</a></li>
<li>However I&#39;d rather not go the traditional web/weave/tangle approach</li>
<li>Instead I want to take a quasi-literate approach where<ul>
<li>all the explantory text/documention and source code is in a single Common Lisp file<ul>
<li>i.e. <a href="../app.lisp">app.lisp</a></li>
</ul>
</li>
<li>the explantory text will be exclusively written<ul>
<li>within Common Lisp&#39;s <a href="http://clhs.lisp.se/Body/02_dhs.htm">multi-line comments</a></li>
<li>in (Github flavoured) Markdown syntax</li>
</ul>
</li>
</ul>
</li>
<li>Obviously there are drawbacks to this approach<ul>
<li>with the biggest one potentially being that I can&#39;t really write this in
a <em>stream of conciousness</em> flow</li>
<li>instead I&#39;ll be taking a (mostly) top-down approach</li>
</ul>
</li>
<li>But there are also considerable advantages:<ul>
<li>The code is easily run, edited and debugged within your favourite editor</li>
<li>There&#39;s no need for the tangle phase</li>
<li>The documentation can be easily generated<ul>
<li>see <a href="../weave.ros">weave.ros</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="code-conventions-style">Code Conventions &amp; Style</h3>
<ul>
<li>Many developers believe <strong>managing complexity</strong> to be the biggest challenge in software development<ul>
<li>so the primary motivation behind the conventions and styles used here are to mitigate this</li>
<li>i.e. the code must be as simple as possible for <strong>humans</strong> to <strong>read</strong> and <strong>maintain</strong></li>
</ul>
</li>
</ul>
<h4 id="programming-paradigm">Programming Paradigm</h4>
<ul>
<li>The code will generally follow a combination of functional and procedural programming, avoiding OOP<ul>
<li>e.g. inheritance, polymorphism, etc.</li>
<li>more and more, developers are finding these constructs<ul>
<li>at least, as they are commonly implemented</li>
<li>to make code even harder to understand</li>
</ul>
</li>
<li>I particuarly like the pitfalls pointed out by the folks behind <a href="https://en.wikipedia.org/wiki/Data,_context_and_interaction">DCI</a><ul>
<li>although I don&#39;t agree with many of their other ideals</li>
</ul>
</li>
</ul>
</li>
<li>Structs are used throughout the codebase over classes since<ul>
<li>they have a good default textual representation</li>
<li>are far less complex</li>
<li>still a good way to group a set of related data</li>
</ul>
</li>
</ul>
<h4 id="error-handling">Error Handling</h4>
<ul>
<li>Errors/exceptions are triggered only in truly unexpected cases<ul>
<li>i.e. due to a programmer error</li>
<li>or an unrecoverable error leaving the app in a bad state</li>
<li>though the same cannot be said for dependencies</li>
</ul>
</li>
<li>So, many functions will return a value indicating a result/error code<ul>
<li>this is encapsulated in an <code>R</code> struct</li>
<li>see <a href="../glu.lisp">glu.lisp</a></li>
</ul>
</li>
</ul>
<h2 id="source-files">Source Files</h2>
<ul>
<li>What follows is a brief description of the main files and folders the compose this app:</li>
<li><a href="../app.lisp">app.lisp</a><ul>
<li>Contains just about <strong>all</strong> of the code and documentation relevant to this project</li>
</ul>
</li>
<li><a href="../docs">docs/</a><ul>
<li><a href="index.html">index.html</a><ul>
<li>The sole documentation file</li>
<li>Generated from<ul>
<li><a href="index.md">index.md</a></li>
<li><a href="template.html">template.html</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="index.md">index.md</a><ul>
<li>Generated from <a href="../app.lisp">app.lisp</a></li>
</ul>
</li>
<li><a href="highlightjs/">highlightjs</a><ul>
<li>Directory containing the syntax highlighting library used by the documentation, <a href="https://highlightjs.org/">highlight.js</a></li>
</ul>
</li>
<li><a href="template.html">template.html</a><ul>
<li>HTML template for this file</li>
<li>Basically contains everything outside the body tag</li>
</ul>
</li>
</ul>
</li>
<li><a href="../EULA">EULA</a><ul>
<li>End-user license agreement</li>
</ul>
</li>
<li><a href="../fileworthy.asd">fileworthy.asd</a><ul>
<li>ASDF system/build description</li>
</ul>
</li>
<li><a href="../glu.lisp">glu.lisp</a><ul>
<li>GLU stands for Global Lisp Utilities</li>
<li>These are my (opinionated) utilities that are not particular to this app per se</li>
</ul>
</li>
<li><a href="../index.html">index.html</a><ul>
<li>Simply redirects to the documentation</li>
<li>This file is needed here to facilitate hosting from github.io</li>
</ul>
</li>
<li><a href="../LICENSE">LICENSE</a><ul>
<li>GPLv3 license</li>
</ul>
</li>
<li><a href="../package.lisp">package.lisp</a><ul>
<li>Contains the sole package definition for this app</li>
</ul>
</li>
<li><a href="../README.md">README.md</a><ul>
<li>Basically contains the intro of this file</li>
</ul>
</li>
<li><a href="../start.lisp">start.lisp</a><ul>
<li>Common Lisp script to start the website with default options</li>
</ul>
</li>
<li><a href="../start.sh">start.sh</a><ul>
<li>Shell script to start the website within a GNU screen session</li>
</ul>
</li>
<li><a href="../static/">static/</a><ul>
<li>Contains static web resources such as CSS, images, Javascript and dependencies</li>
</ul>
</li>
<li><a href="../version">version</a><ul>
<li>Current version of the app</li>
<li>The version will follow a simple MAJOR.MINOR form<ul>
<li>A change to the major version indicates<ul>
<li>significant changes</li>
<li>or breaking changes</li>
</ul>
</li>
<li>A change to the minor version indicates<ul>
<li>non-major changes</li>
<li>changes can be bug fixes and features</li>
</ul>
</li>
<li><em>0.x</em> versions are considered alpha/beta<ul>
<li>and so will regularly introduce breaking changes</li>
</ul>
</li>
</ul>
</li>
<li>The version is quoted so we can easily read the file through a Common Lisp function as a string</li>
</ul>
</li>
<li><a href="../weave.ros">weave.ros</a><ul>
<li>Common Lisp script that transforms a Common Lisp source file into Markdown and HTML</li>
<li>it can also monitor the source file for changes via <a href="https://github.com/rvoicilas/inotify-tools">inotify tools</a></li>
<li><a href="https://github.com/roswell/roswell">Roswell</a> is needed to run this script, e.g.:<ul>
<li><code>./weave.ros -m app.lisp</code></li>
<li>This will monitor <em>app.lisp</em> and generate the following whenever it changes:<ul>
<li><em>./docs/index.md</em></li>
<li><em>./docs/index.html</em></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="libraries">Libraries</h2>
<ul>
<li>The following libaries are used by this app:</li>
</ul>
<h3 id="back-end-server-side">Back-end/Server-side</h3>
<ul>
<li><a href="https://common-lisp.net/project/alexandria/">Alexandria</a><ul>
<li>Minimal utility library that seems to be highly recommended</li>
</ul>
</li>
<li><a href="http://clacklisp.org/">Clack</a><ul>
<li>Abstract web framework library</li>
<li>Sits on top of tools like Hunchentoot, Woo, etc.</li>
</ul>
</li>
<li><a href="https://github.com/arielnetworks/cl-markup">CL-MARKUP</a><ul>
<li>Easy way to generate HTML in Lisp-friendly syntax</li>
</ul>
</li>
<li><a href="http://weitz.de/cl-ppcre/">CL-PPCRE</a><ul>
<li>Defacto regular expression library</li>
</ul>
</li>
<li><a href="http://weitz.de/hunchentoot/">Hunchentoot</a><ul>
<li>Web server and framework</li>
</ul>
</li>
<li><a href="https://common-lisp.net/project/local-time/">LOCAL-TIME</a><ul>
<li>Easily manipulate and display date and times</li>
</ul>
</li>
<li><a href="http://www.cliki.net/split-sequence">SPLIT-SEQUENCE</a><ul>
<li>Easily split sequences by arbitrary delimiters</li>
</ul>
</li>
<li><a href="https://github.com/fare/asdf/tree/master/uiop">UIOP</a><ul>
<li>Portable, OS and file-system utilities</li>
<li>This is actually part of the core of <a href="https://github.com/fare/asdf">ASDF</a></li>
</ul>
</li>
</ul>
<h3 id="front-end-client-side">Front-end/Client-side</h3>
<ul>
<li><a href="http://fontawesome.io/">Font Awesome</a><ul>
<li>Rich set of icons as a font</li>
</ul>
</li>
<li><a href="https://highlightjs.org/">Highlight.js</a><ul>
<li>Code/syntax highlighting</li>
</ul>
</li>
<li><a href="https://lodash.com/">Lodash</a><ul>
<li>Utility library with many useful functional list operations</li>
</ul>
</li>
<li><a href="https://github.com/chjj/marked">Marked.js</a><ul>
<li>Transforms Markdown to HTML</li>
</ul>
</li>
<li><a href="http://momentjs.com/">Moment.js</a><ul>
<li>Date/time utilities</li>
</ul>
</li>
</ul>
<h2 id="system-definition">System Definition</h2>
<ul>
<li>Okay, on to the code finally!</li>
<li>See <a href="../fileworthy.asd">fileworthy.asd</a> for the ASDF build system definition<ul>
<li>describing high-level project details</li>
<li>and dependencies needed to build the project</li>
</ul>
</li>
<li>This needs to be a separate file to work with some tools<ul>
<li>e.g. ASDF and <a href="https://www.quicklisp.org/">Quicklisp</a></li>
<li>otherwise I might&#39;ve embedded it here</li>
</ul>
</li>
<li>All of the other code will be in a single file:<ul>
<li><a href="../app.lisp">app.lisp</a></li>
<li>I&#39;m not sure if this is a good idea</li>
<li>I&#39;m choosing to go this route as it simplifies my <a href="../weave.ros">current tooling</a> with Literate Programming</li>
</ul>
</li>
</ul>
<h2 id="package-definition">Package Definition</h2>
<ul>
<li>We&#39;ll use a single package named <code>FILEWORTHY</code> for the entire application</li>
<li>I&#39;m not sure if this is a good idea<ul>
<li>just trying out a different approach</li>
<li>let&#39;s see how it works out</li>
</ul>
</li>
<li>See <a href="../package.lisp">package.lisp</a> for the code</li>
<li>The reason it&#39;s in a separate file is so that we can have the package
defined before we compile the source files that depend on it<ul>
<li>e.g. <a href="../glu.lisp">glu.lisp</a></li>
</ul>
</li>
</ul>
<pre><code class="lang-lisp">(in-package :fileworthy)
</code></pre>
<h2 id="app">APP</h2>
<ul>
<li>The <code>APP</code> struct groups general, high-level app details including<ul>
<li><code>DEBUG</code><ul>
<li>whether the site is running in a debug mode</li>
</ul>
</li>
<li><code>APP-DIR</code><ul>
<li>the root directory of the app&#39;s source/binaries</li>
</ul>
</li>
<li><code>MIN-PASSWORD-LENGTH</code><ul>
<li>the minimum allowed password length</li>
</ul>
</li>
<li><code>VERSION</code><ul>
<li>the current version of the app</li>
</ul>
</li>
<li><code>LAST-UPDATED</code><ul>
<li>the time the app was last updated</li>
<li>based on the last write time of the <a href="../version">version file</a></li>
</ul>
</li>
<li><code>WEB-STATIC-DIR</code><ul>
<li>the directory containing static client-side web resources</li>
</ul>
</li>
<li><code>CONFIG-FILE-PATH</code><ul>
<li>the fully qualified path to the config file</li>
<li>which is an instance of <code>CONFIG</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="lang-lisp">(defstruct app
  &quot;Contains general, high-level app details.&quot;
  (debug t)
  (app-dir (empty &#39;pathname) :type PATHNAME)
  (min-password-length 4 :type INTEGER)
  (version &quot;0.0&quot; :type STRING)
  (last-updated (empty &#39;timestamp) :type TIMESTAMP)
  (web-static-dir (empty &#39;pathname) :type PATHNAME)
  (config-file-path (empty &#39;pathname) :type PATHNAME))

(empty=&gt; (local-time:encode-timestamp 0 0 0 0 1 1 1))
(empty=&gt; (make-app))
</code></pre>
<h3 id="-config-"><code>CONFIG</code></h3>
<ul>
<li>This struct encapsulates user-configurable settings<ul>
<li><code>SITE-NAME</code><ul>
<li>the name for the website</li>
</ul>
</li>
<li><code>ROOT-DIR</code><ul>
<li>the root directory from which the website is generated</li>
</ul>
</li>
<li><code>ALLOW-ANONYMOUS-READ</code><ul>
<li>whether users that are not logged in are able to access the website</li>
</ul>
</li>
<li><code>RESERVED-RESOURCE-PATH</code><ul>
<li>the path within the site that is reserved for app-specific resources</li>
<li>essentially everything outside of a file-system path designation:<ul>
<li>static files (javascript, css, etc)</li>
<li>admin pages</li>
<li>other custom pages</li>
</ul>
</li>
</ul>
</li>
<li><code>NEXT-USER-ID</code><ul>
<li>holds the identifier that will be used for the next new user</li>
</ul>
</li>
<li><code>USERS</code><ul>
<li>all registered users</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="lang-lisp">(defstruct config
  (site-name &quot;&quot; :type STRING)
  (root-dir &quot;&quot; :type STRING)
  (port 0 :type INTEGER)
  (allow-anonymous-read t)
  (reserved-resource-path &quot;&quot; :type STRING)
  (next-user-id 1 :type INTEGER)
  (users &#39;() :type LIST))

(empty=&gt; (make-config))

;; TODO: expand environment variables in ROOT-DIR
(defun load-config (path)
  &quot;Load an instance of `CONFIG` from the config file.&quot;
  (let* ((config (read-file-form path)))
    ;; If no root dir is specified, use user&#39;s home dir
    (if (blank? (config-root-dir config))
      (setf (config-root-dir config)
            (to-string (uiop/common-lisp:user-homedir-pathname))))
    (if (not (char-equal #\/
                         (char (config-root-dir config)
                               (1- (length (config-root-dir config))))))
      (setf (config-root-dir config)
            (sf &quot;~A/&quot; (config-root-dir config))))
    (if (not (directory-exists-p (config-root-dir config)))
      (error (sf &quot;Directory &#39;~A&#39; not found or inaccessible.&quot;
                 (config-root-dir config))))
    config))
</code></pre>
<h2 id="global-variables">Global Variables</h2>
<ul>
<li>I&#39;m trying to keep the number of global objects as small as possible</li>
<li>All of the following will be initialised when <code>START-APP</code> is called<ul>
<li>so we don&#39;t bother initialising them here</li>
</ul>
</li>
</ul>
<pre><code class="lang-lisp">(defvar *app*
  (empty &#39;app)
  &quot;Singleton instance containing general app details.&quot;)

(defvar *config*
  (empty &#39;config)
  &quot;Singleton instance contain config details.&quot;)

(defvar *acceptor*
  nil
  &quot;Singleton Hunchentoot web handler.&quot;)
</code></pre>
<h3 id="create-app">CREATE-APP</h3>
<ul>
<li>This function creates an instance of <code>APP</code><ul>
<li>with all fields properly initialised</li>
</ul>
</li>
<li>Note that <code>APP-VERSION</code> is loaded from a separate <a href="../version">version file</a><ul>
<li>this is partly due to <a href="../fileworthy.asd">fileworthy.asd</a> needing access to the app version as well</li>
<li>and this way we have a single place where the version gets updated<ul>
<li>and it&#39;s easily modified and read from</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="lang-lisp">(defun create-app (debug)
  &quot;Create APP instance.&quot;
  (let* ((app-dir (asdf:system-source-directory :fileworthy))
         (version-file-path (asdf:system-relative-pathname
                              :fileworthy
                              &quot;version&quot;))
         (xdg-config-home (xdg-config-home))
         (config-file-name &quot;config&quot;)
         (config-file-dir &quot;&quot;)
         (config-file-path &quot;&quot;))

    ;; If $XDG_CONFIG_HOME not set, set it to ~/.config
    (if (empty? xdg-config-home)
      (setf xdg-config-home (merge-pathnames* &quot;.config&quot; (user-homedir-pathname))))

    (setf config-file-dir (merge-pathnames* &quot;fileworthy/&quot; xdg-config-home))
    (setf config-file-path (merge-pathnames* config-file-name config-file-dir))

    (when (not (directory-exists-p config-file-dir))
      (format t
              &quot;Creating &#39;~A&#39; as it doesn&#39;t exist.~%&quot;
              config-file-dir)
      (ensure-directories-exist config-file-dir))

    (when (not (file-exists-p config-file-path))
      (format t
              &quot;Creating &#39;~A&#39; from default config as it doesn&#39;t exist.~%&quot;
              config-file-path)
      (copy-file (merge-pathnames* &quot;config&quot; app-dir) config-file-path))

    (make-app :debug debug
              :app-dir app-dir 
              :version (asdf::read-file-form version-file-path)
              :last-updated
              (universal-to-timestamp
                (file-write-date version-file-path))
              :web-static-dir (merge-pathnames #P&quot;static/&quot; app-dir)
              :config-file-path config-file-path)))
</code></pre>
<h2 id="startup-and-shutdown">Startup and Shutdown</h2>
<ul>
<li>To launch the website with the default values we need only call <code>START-APP</code></li>
</ul>
<h3 id="-start-app-"><code>START-APP</code></h3>
<ul>
<li>This function starts the app<ul>
<li>including the underlying web server</li>
<li>by default at <a href="http://localhost:9090">http://localhost:9090</a></li>
</ul>
</li>
<li>Parameters:<ul>
<li><code>PORT</code><ul>
<li>the port of the web server</li>
<li>if no value is specified here it is taken from the config, <code>CONFIG</code></li>
</ul>
</li>
<li><code>DEBUG</code><ul>
<li>whether to start the web server in debug mode where:<ul>
<li>errors are caught by the debugger</li>
<li>errors are shown in HTML output<ul>
<li>rather than showing a friendly &quot;server error&quot; page</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Returns:<ul>
<li>an <code>R</code> result</li>
</ul>
</li>
<li>Side-effects:<ul>
<li>sets <code>*ACCEPTOR*</code> and <code>*APP*</code></li>
<li>since the Hunchentoot web server is started<ul>
<li>this may initialise its own global variables</li>
<li>and produce it&#39;s own side-effects</li>
<li>this function explicitly sets the following Hunchentoot global vars:<ul>
<li><code>*CATCH-ERRORS-P*</code></li>
<li><code>*SHOW-LISP-ERRORS-P*</code></li>
</ul>
</li>
</ul>
</li>
<li>calls <code>DEFINE-ROUTES</code><ul>
<li>which has its own side-effects</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="lang-lisp">(defun start-app (&amp;key (port 9090 port-given?) (debug t))
  &quot;Starts the app.&quot;

  (if *acceptor*
    (let* ((res (new-r :error &quot;Server is already running.&quot;)))
      (format t (r-message res))
      (return-from start-app res)))

  (setf *app* (create-app debug))
  (setf *config* (load-config (app-config-file-path *app*)))

  (if (not port-given?)
    (setf port (config-port *config*)))

  (setf *acceptor* (create-web-acceptor :port port :debug debug))

  (define-routes)

  (when debug
    (setf *catch-errors-p* nil)
    (setf *show-lisp-errors-p* t))

  (start *acceptor*)

  (setf *session-max-time* (* 60 60 24 30 3)) ; 3 months

  (let* ((res (new-r :success
                     (sf &quot;Fileworthy ~A started on port ~A, working out of &#39;~A&#39;.&quot;
                         (app-version *app*)
                         port
                         (config-root-dir *config*)))))
    (format t (r-message res))
    res))
</code></pre>
<h3 id="-stop-app-"><code>STOP-APP</code></h3>
<ul>
<li>This function gracefully shuts down the app<ul>
<li>including the underlying web server</li>
</ul>
</li>
</ul>
<pre><code class="lang-lisp">(defun stop-app ()
  &quot;Stops the app.&quot;
  (when *acceptor*
    (stop *acceptor* :soft t)
    (setf *acceptor* nil)
    (format t &quot;Stopped Fileworthy ~A~%&quot; (app-version *app*))))
</code></pre>
<h3 id="-restart-app-"><code>RESTART-APP</code></h3>
<ul>
<li>This function restarts the app<ul>
<li>including the underlying web server</li>
</ul>
</li>
</ul>
<pre><code class="lang-lisp">(defun restart-app (&amp;key (debug t))
  &quot;Restarts the app.&quot;
  (stop-app)
  (start-app :debug debug))
</code></pre>
<h3 id="-create-web-acceptor-"><code>CREATE-WEB-ACCEPTOR</code></h3>
<ul>
<li>This function creates the Hunchentoot (easy) acceptor</li>
<li>See <code>START-APP</code> for a description of the parameters<ul>
<li>as it uses the exact same list</li>
</ul>
</li>
</ul>
<pre><code class="lang-lisp">(defun create-web-acceptor (&amp;key (port 9090) (debug t))
  &quot;Creates an &#39;easy-acceptor&#39; which will listen on the specified port.&quot;
  (make-instance &#39;easy-acceptor
                 :port port
                 :document-root (app-web-static-dir *app*)
                 :access-log-destination (if debug
                                           *standard-output*
                                           &quot;tbnl-access.log&quot;)
                 :message-log-destination (if debug
                                            *standard-output*
                                            &quot;tbnl-message.log&quot;)))
</code></pre>
<h2 id="core-domain-logic">Core Domain Logic</h2>
<h3 id="-user-"><code>USER</code></h3>
<ul>
<li>This struct encapsulates a user account</li>
</ul>
<pre><code class="lang-lisp">(defstruct user
  (id 0 :type INTEGER)
  (name &quot;&quot; :type STRING)
  (email &quot;&quot; :type STRING)
  (password &quot;&quot; :type STRING)
  (salt &quot;&quot; :type STRING)
  (admin? nil :type BOOLEAN))

(empty=&gt; (make-user))

(defun get-user (&amp;key (id 0 id-given?) name email)
  &quot;Get user with one or more of the specified parameters.&quot;
  (if (or id-given? name email)
    (find-if (位 (user)
                (and (or (not id-given?) (= id (user-id user)))
                     (or (null name) (string-equal name (user-name user)))
                     (or (null email) (string-equal email (user-email user)))))
             (config-users *config*))))

(defun authenticate-user (user pwd)
  &quot;Authenticate the given user.&quot;
  (and user
       (not (blank? pwd))
       (string= (gen-hash pwd (user-salt user))
                (user-password user))))
</code></pre>
<h3 id="-random-string-"><code>RANDOM-STRING</code></h3>
<ul>
<li>The Iron Clad function is wrapped in <code>TO-STRING</code> so that it prints like a
regular string (e.g. used when saving config to disk)<ul>
<li>otherwise the printed representation has &quot;COERCE...&quot;</li>
</ul>
</li>
</ul>
<pre><code class="lang-lisp">(defun random-string (&amp;optional (n 16))
  &quot;Return a random hex string with N digits.&quot;
  (to-string (ironclad:byte-array-to-hex-string (ironclad:make-random-salt n))))
</code></pre>
<h3 id="-gen-hash-"><code>GEN-HASH</code></h3>
<ul>
<li>The Iron Clad function is wrapped in <code>TO-STRING</code> so that it prints like a
regular string (e.g. used when saving config to disk)<ul>
<li>otherwise the printed representation has &quot;COERCE...&quot;</li>
</ul>
</li>
</ul>
<pre><code class="lang-lisp">(defun gen-hash (to-hash &amp;optional salt)
  &quot;Generate a hash of TO-HASH.&quot;
  (to-string
    (ironclad:byte-array-to-hex-string
      (ironclad:digest-sequence :sha512
                                (ironclad:ascii-string-to-byte-array
                                  (sf &quot;~A~A&quot; to-hash (or salt &quot;&quot;)))))))
</code></pre>
<h3 id="-get-dir-names-"><code>GET-DIR-NAMES</code></h3>
<ul>
<li>This function gets a list of directory names relative to either<ul>
<li>the given directory, <code>PARENT</code></li>
<li>or the root working folder as specified by <code>CONFIG-ROOT-DIR</code></li>
</ul>
</li>
</ul>
<pre><code class="lang-lisp">(defun get-dir-names (&amp;optional (parent &quot;&quot;))
  &quot;Get directory names.&quot;
  (map &#39;list
       (位 (abs-dir)
          (last1 (split-sequence #\/
                                 (princ-to-string abs-dir)
                                 :remove-empty-subseqs t)))
       (uiop/filesystem:subdirectories
         (concatenate &#39;string
                      (config-root-dir *config*)
                      (string-left-trim &#39;(#\/) parent)))))
</code></pre>
<h3 id="-get-file-names-"><code>GET-FILE-NAMES</code></h3>
<ul>
<li>This function gets a list of file names relative to either<ul>
<li>the given directory <code>PARENT</code></li>
<li>or the root working folder as specified by <code>CONFIG-ROOT-DIR</code></li>
</ul>
</li>
</ul>
<pre><code class="lang-lisp">(defun get-file-names (&amp;optional parent)
  &quot;Get file names.&quot;
  (map &#39;list
       (位 (abs-file)
          (last1 (split-sequence #\/
                                 (princ-to-string abs-file)
                                 :remove-empty-subseqs t)))
       (uiop/filesystem:directory-files
         (or parent (config-root-dir *config*)))))
</code></pre>
<h3 id="-get-file-content-"><code>GET-FILE-CONTENT</code></h3>
<pre><code class="lang-lisp">(defun get-file-content (path)
  &quot;Get file contents of `PATH`.&quot;
  (with-open-file (stream path)
    (let ((data (make-string (file-length stream))))
      (read-sequence data stream)
      data)))
</code></pre>
<h3 id="-pretty-time-"><code>PRETTY-TIME</code></h3>
<pre><code class="lang-lisp">(defun pretty-time (time)
  &quot;Formats a date/time to a user-friendly form. TIME is expected to either be a
   timestamp readable by LOCAL-TIME, or a LOCAL-TIME:TIMESTAMP object.&quot;
  (if (empty? time)
      &quot;&quot;
      (let* ((format-desc &#39;())
             (timestamp (if (stringp time)
                            (parse-timestring time)
                            time)))

        (setf format-desc &#39;(:short-weekday &quot; &quot; :short-month &quot; &quot; :day &quot; &quot;
                            :year &quot;, &quot; :hour12 &quot;:&quot; (:min 2) &quot; &quot; :ampm))

        (format-timestring nil timestamp :format format-desc))))
</code></pre>
<h3 id="-is-file-binary-"><code>IS-FILE-BINARY?</code></h3>
<ul>
<li>This function attempts to determine whether the given path is a binary file</li>
<li>It does this with a very simple technique of looking for a 0 byte</li>
<li>This technique should work with ASCII and UTF-8 files<ul>
<li>but not UTF-16 and UTF-32</li>
</ul>
</li>
</ul>
<pre><code class="lang-lisp">(defun is-file-binary? (path)
  &quot;Try to detect if PATH is a binary file.&quot;
  (with-open-file (stream path
                          :element-type &#39;(unsigned-byte 8)
                          :if-does-not-exist nil)
    (loop :for i :from 0
          :for b = (read-byte stream nil nil)
          :while b
          :when (zerop b)
          :do (return-from is-file-binary? t)))
  nil)
</code></pre>
<h3 id="-create-config-lock-file-"><code>CREATE-CONFIG-LOCK-FILE</code></h3>
<pre><code class="lang-lisp">(defun create-config-lock-file ()
  &quot;Create a file indicating that the config file is locked.&quot;
  (let* ((lock-file (sf &quot;~A.lck&quot; (app-config-file-path *app*))))
    (with-open-file (stream
                      lock-file
                      :direction :output
                      :if-exists nil
                      :if-does-not-exist :create)
      (if (null stream)
        (new-r :warning &quot;Config file is already locked.&quot;)
        (progn
          (format stream &quot;~A&quot; (get-universal-time))
          (new-r :success &quot;Config file lock created.&quot;))))))
</code></pre>
<h3 id="-delete-config-lock-file">`DELETE-CONFIG-LOCK-FILE</h3>
<pre><code class="lang-lisp">(defun delete-config-lock-file ()
  &quot;Delete config lock file.&quot;
  (delete-file-if-exists (sf &quot;~A.lck&quot; (app-config-file-path *app*))))
</code></pre>
<h3 id="-save-config-"><code>SAVE-CONFIG</code></h3>
<ul>
<li><code>CHANGE-FN</code> is a function that performs the work of making changes to the
global <code>*CONFIG*</code> object</li>
<li>This function is only called if the config file lock is successfully obtained</li>
</ul>
<pre><code class="lang-lisp">(defun save-config (change-fn)
  &quot;Save/update config file with contents of `*CONFIG*`.&quot;
  (let* ((lockedR (create-config-lock-file)))
    (if (failed? lockedR)
      (return-from save-config lockedR))
    (with-open-file (stream
                      (app-config-file-path *app*)
                      :direction :output
                      :if-exists :supersede
                      :if-does-not-exist :create)
      (funcall change-fn)
      (write *config* :stream stream :readably t))
    (delete-config-lock-file))
  (new-r :success &quot;Config updated.&quot;))
</code></pre>
<h2 id="web-utils">Web Utils</h2>
<ul>
<li>This section contains common utility functions for the web-related code</li>
</ul>
<h3 id="-session-cookie-name-"><code>SESSION-COOKIE-NAME</code></h3>
<ul>
<li>Let&#39;s use a custom session name<ul>
<li>rather than the default: &quot;hunchentoot-session&quot;</li>
</ul>
</li>
</ul>
<pre><code class="lang-lisp">(defmethod session-cookie-name ((acceptor easy-acceptor))
  &quot;fileworthy-session&quot;)

(defun set-http-code (code)
  &quot;Set the current request&#39;s HTTP status code to `CODE`.&quot;
  (setf (return-code*) code))

(defun url-for (section-or-obj)
  &quot;Create URL for a particular section/object&quot;
  (cond ((eq &#39;about section-or-obj)
         (sf &quot;/~A/about&quot;
             (config-reserved-resource-path *config*)))
        ((eq &#39;settings section-or-obj)
         (sf &quot;/~A/settings&quot;
             (config-reserved-resource-path *config*)))
        ((eq &#39;users section-or-obj)
         (sf &quot;/~A/users&quot;
             (config-reserved-resource-path *config*)))
        ((typep section-or-obj &#39;user)
         (if (= 0 (user-id section-or-obj))
           (sf &quot;/~A/users/new&quot;
               (config-reserved-resource-path *config*))
           (sf &quot;/~A/users/~A/~(~A~)&quot;
               (config-reserved-resource-path *config*)
               (user-id section-or-obj)
               (user-name section-or-obj))))
        (t &quot;&quot;)))

(defun json-result (result &amp;optional data)
  &quot;Converts the given R instance to a JSON string.&quot;
  (json:encode-json-plist-to-string
    `(level ,(r-level result)
            message ,(r-message result)
            data ,data)))

(defun json-error (status-code)
  &quot;Create a JSON response indicating an error with the specified HTTP status
   code.&quot;
  (set-http-code status-code)
  (json:encode-json-plist-to-string
    &#39;(level error
            message &quot;Sorry, you don&#39;t have permission to perform this request.&quot;)))

(defun set-auth-cookie (name value)
  &quot;Create a secure cookie.&quot;
  (set-cookie name
              :value value
              ;; Expire a month from now
              :max-age (* 60 60 24 30)
              :path &quot;/&quot;
              :secure (not (app-debug *app*))
              :http-only t))

(defun parse-js-bool (val)
  &quot;Parse a Javascript boolean taken from a post parameter to a Lisp bool.&quot;
  (or (string-equal &quot;true&quot; val)
      (string-equal &quot;1&quot; val)))
</code></pre>
<h2 id="web-resource-routes">Web Resource Routes</h2>
<ul>
<li>Route are defined in a function since<ul>
<li>we need to have the <code>*APP*</code> instance initialised first</li>
<li>the page functions are defined below this point</li>
</ul>
</li>
</ul>
<pre><code class="lang-lisp">(defun define-routes ()
  &quot;Define web resource routes.&quot;
  (setq *dispatch-table*
        (list
          ;; Static files
          (create-folder-dispatcher-and-handler
            (sf &quot;/~A/css/&quot;
                (config-reserved-resource-path *config*))
            (merge-pathnames* &quot;css/&quot; (app-web-static-dir *app*)))
          (create-folder-dispatcher-and-handler
            (sf &quot;/~A/deps/&quot;
                (config-reserved-resource-path *config*))
            (merge-pathnames* &quot;deps/&quot; (app-web-static-dir *app*)))
          (create-folder-dispatcher-and-handler
            (sf &quot;/~A/js/&quot;
                (config-reserved-resource-path *config*))
            (merge-pathnames* &quot;js/&quot; (app-web-static-dir *app*)))

          ;; About page
          (create-regex-dispatcher
            (sf &quot;^/~A/about/?$&quot;
                (config-reserved-resource-path *config*))
            #&#39;page-about)

          ;; Settings page
          (create-regex-dispatcher
            (sf &quot;^/~A/settings/?$&quot;
                (config-reserved-resource-path *config*))
            #&#39;page-settings)

          ;; Settings save API
          (create-regex-dispatcher
            (sf &quot;^/~A/api/settings/?$&quot;
                (config-reserved-resource-path *config*))
            #&#39;api-settings-save)

          ;; User list page
          (create-regex-dispatcher
            (sf &quot;^/~A/users/?$&quot;
                (config-reserved-resource-path *config*))
            #&#39;page-user-list)

          ;; User detail page
          (create-regex-dispatcher
            (sf &quot;^/~A/users/.+/?$&quot;
                (config-reserved-resource-path *config*))
            #&#39;page-user-detail)

          ;; User save API
          (create-regex-dispatcher
            (sf &quot;^/~A/api/users/.+/?$&quot;
                (config-reserved-resource-path *config*))
            #&#39;api-user-save)

          ;; Login API
          (create-regex-dispatcher
            (sf &quot;^/~A/api/login/?$&quot;
                (config-reserved-resource-path *config*))
            #&#39;api-login)

          ;; Logout page
          (create-regex-dispatcher
            (sf &quot;^/~A/logout/?$&quot;
                (config-reserved-resource-path *config*))
            #&#39;page-logout)

          ;; File-system path page
          (create-regex-dispatcher
            &quot;^/*&quot;
            #&#39;page-fs-path))))
</code></pre>
<h2 id="web-pages">Web Pages</h2>
<ul>
<li>All web page-related functions will be prefixed with <code>PAGE-</code></li>
</ul>
<h3 id="-page-template-"><code>PAGE-TEMPLATE</code></h3>
<ul>
<li>This function defines the template all pages will use</li>
<li>Parameters:<ul>
<li><code>TITLE</code><ul>
<li>the title of the page</li>
<li>note that the given title is<ul>
<li>suffixed with the site&#39;s name and project name (Fileworthy)</li>
<li>and separated by a hyphen</li>
<li>e.g. &quot;Home - My Documents - Fileworthy&quot;</li>
</ul>
</li>
</ul>
</li>
<li><code>PAGE-ID</code><ul>
<li>the unique id of the page set on main element</li>
</ul>
</li>
<li><code>CONTENT</code><ul>
<li>the HTML of the page as a raw string</li>
<li>note that the caller is responsible for properly escaping special characters</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="lang-lisp">(defun page-template (title page-id content)
  &quot;Base template for all web pages.&quot;
  (let* ((rrp (config-reserved-resource-path *config*))
         (user (empty &#39;user :unless (session-value &#39;user)))
         (path-name (script-name* *request*))
         (path-segs (split-sequence #\/ path-name :remove-empty-subseqs t))
         (first-path-seg (first path-segs))
         (fw-info-page? (string-equal rrp first-path-seg)))
    (html5 :lang &quot;en&quot;
           (:head
             (:meta :charset &quot;utf-8&quot;)
             (:meta :http-equiv &quot;X-UA-Compatible&quot; :content &quot;IE=edge&quot;)
             (:meta
               :name &quot;viewport&quot;
               :content &quot;width=device-width, initial-scale=1&quot;)
             (:title
               (sf &quot;~A - ~A - Fileworthy&quot;
                   title
                   (config-site-name *config*)))

             (:link :href &quot;/images/favicon.ico&quot; :rel &quot;shortcut icon&quot;)
             (:link
               :href
               (sf &quot;/~A/deps/font-awesome/css/font-awesome.min.css&quot; rrp)
               :rel &quot;stylesheet&quot;
               :type &quot;text/css&quot;)
             (:link
               :href (sf &quot;/~A/deps/highlightjs/styles/github.css&quot; rrp)
               :rel &quot;stylesheet&quot;)
             (:link :href (sf &quot;/~A/css/main.css&quot; rrp) :rel &quot;stylesheet&quot;)
             (:link :href (sf &quot;/~A/css/main.mobile.css&quot; rrp) :rel &quot;stylesheet&quot;)
             (:link :href (sf &quot;/~A/css/main.print.css&quot; rrp) :rel &quot;stylesheet&quot;)

             (:script :src (sf &quot;/~A/deps/lodash/lodash.min.js&quot; rrp) &quot;&quot;)
             (:script :src (sf &quot;/~A/deps/momentjs/moment.min.js&quot; rrp) &quot;&quot;)
             (:script :src (sf &quot;/~A/deps/markedjs/marked.min.js&quot; rrp) &quot;&quot;)
             (:script
               :src (sf &quot;/~A/deps/highlightjs/highlight.pack.js&quot; rrp) &quot;&quot;)
             (:script :src (sf &quot;/~A/js/utils.js&quot; rrp) &quot;&quot;)
             (:script :src (sf &quot;/~A/js/main.js&quot; rrp) &quot;&quot;))
           (:body
             :data-rrp rrp
             ;; Overlay (for dialogs)
             (:div :id &quot;overlay&quot; :class &quot;hidden&quot; &quot;&amp;nbsp;&quot;)
             ;; Top Bar
             (:header :id &quot;top-bar&quot;
              ;; Menu Bar Icon

              ;; Site Name
              (:a :id &quot;app-name&quot; :href &quot;/&quot;
               (config-site-name *config*))
              ;; User Info
              (:div :id &quot;user-info&quot;
               (if (empty? user)
                 ;; Logged Out
                 (raw
                   (markup
                     (:a :href &quot;javascript:site.showLogin()&quot;
                      (:i :class &quot;fa fa-sign-in&quot; &quot;&quot;)
                      &quot; Log In&quot;)))
                 ;; Logged In
                 (raw
                   (markup
                     (:a
                       :href (url-for user)
                       (user-name user))
                     (:span &quot; &quot;)
                     (:a
                       :href (sf &quot;/~A/logout&quot; rrp)
                       :title &quot;Log Out&quot;
                       (:i :class &quot;fa fa-sign-out&quot; &quot;&quot;))))))
              (:div :class &quot;clear-fix&quot;))
             (:nav
               (:ul :id &quot;main-menu-items&quot; :class &quot;flat-list&quot;
                ;; Home Folder Icon
                (:li
                  :class (if (empty? first-path-seg) &quot;selected&quot;)
                  (:a :href &quot;/&quot; :title &quot;Home&quot;
                   (:i :class &quot;fa fa-home&quot; &quot;&quot;)))
                ;; Menu Icon
                (:li
                  :class (if fw-info-page? &quot;selected&quot;)
                  (:a :href &quot;javascript:site.toggleMenu()&quot; :title &quot;Main menu&quot;
                   (:i :class &quot;fa fa-bars&quot; &quot; &quot;)))
                ;; Root Folders
                (if (or (config-allow-anonymous-read *config*)
                        (not (empty? user)))
                  (loop
                    :for dir-name :in (get-dir-names)
                    :collect (markup
                               (:li
                                 (:a
                                   :class
                                   (if (string= first-path-seg dir-name)
                                     &quot;selected&quot;
                                     nil)
                                   :href (sf &quot;/~A/&quot; dir-name)
                                   dir-name))))))
               ;; Fileworthy Info/Settings
               (:ul
                 :id &quot;info-menu&quot;
                 :class (if fw-info-page?
                          &quot;sub-menu-items flat-list&quot;
                          &quot;sub-menu-items flat-list hidden&quot;)
                (:li
                  :class (if (string-equal &quot;about&quot; (nth 1 path-segs)) &quot;selected&quot;)
                  (:a :href (url-for &#39;about) &quot;About&quot;))
                (if (user-admin? user)
                  (raw
                    (markup
                      (:li
                        :class (if (string-equal &quot;settings&quot; (nth 1 path-segs))
                                 &quot;selected&quot;)
                        (:a :href (url-for &#39;settings) &quot;Settings&quot;)
                        ))))
                (if (not (empty? user))
                  (raw
                    (markup
                      (:li
                        :class (if (and (string-equal &quot;users&quot;
                                                      (nth 1 path-segs))
                                        (string-equal (to-string (user-id user))
                                                      (nth 2 path-segs)))
                                 &quot;selected&quot;)
                        (:a
                          :href (url-for user)
                          &quot;My Account&quot;)))))
                (if (user-admin? user)
                  (raw
                    (markup
                      (:li
                        :class (if (and (string-equal &quot;users&quot;
                                                      (nth 1 path-segs))
                                        (empty? (nth 2 path-segs)))
                                 &quot;selected&quot;)
                        (:a :href (url-for &#39;users) &quot;Users&quot;))))))
               ;; Sub-folders
               (let* ((expanded-dirs (expand-sub-dirs path-name))
                      (sub-dir-name-lst (map &#39;list
                                             (位 (sub-dir)
                                                (get-dir-names sub-dir))
                                             expanded-dirs)))
                 (loop :for sub-dir-names :in sub-dir-name-lst
                       :for i :from 0
                       :when (not (empty? sub-dir-names))
                       :collect
                       (markup
                         (:ul :class &quot;sub-menu-items flat-list&quot;
                          (loop :for dir-name :in sub-dir-names
                                :collect
                                (markup
                                  (:li
                                    (:a
                                      :class
                                      (if (string= dir-name
                                                   (nth (1+ i) path-segs))
                                        &quot;selected&quot;
                                        nil)
                                      :href (sf &quot;/~A/~A/&quot;
                                                (nth i expanded-dirs)
                                                dir-name)
                                      dir-name)))))))))
             (:main :id page-id
               (raw content))
             ;; Login Dialog
             (:section :id &quot;login-dialog&quot; :class &quot;dialog&quot;
              (:div :class &quot;dialog-content&quot;
               (:h2 &quot;Welcome!&quot;)
               (:p
                 (:input
                   :id &quot;login-email-address&quot;
                   :class &quot;full-width&quot;
                   :onkeyup &quot;ui.onEnter(event, site.login)&quot;
                   :placeholder &quot;Email Address&quot;
                   :title &quot;Email Address&quot;
                   :type &quot;text&quot;))
               (:p
                 (:input
                   :id &quot;login-pwd&quot;
                   :class &quot;full-width&quot;
                   :onkeyup &quot;ui.onEnter(event, site.login)&quot;
                   :placeholder &quot;Password&quot;
                   :title &quot;Password&quot;
                   :type &quot;password&quot;))
               (:p :id &quot;login-result&quot;)
               (:p
                 (:a
                   :id &quot;login-btn&quot;
                   :class &quot;button full-width&quot;
                   :href &quot;javascript:site.login()&quot;
                   &quot;Log In&quot;))
               (:p
                 (:a
                   :id &quot;forgot-pwd&quot;
                   :href &quot;javascript:forgotPwd()&quot;
                   :style &quot;float:left&quot;
                   &quot;Forgot password&quot;)
                 (:a
                   :href &quot;javascript:site.closeLogin()&quot;
                   :style &quot;float:right&quot;
                  &quot;Close&quot;))))))))
</code></pre>
<ul>
<li>An example call of the following is:<ul>
<li>&quot;root/sub1/sub1a&quot; ==&gt; &#39;(&quot;root&quot;, &quot;root/sub1&quot;, &quot;root/sub1/sub1a&quot;)</li>
</ul>
</li>
</ul>
<pre><code class="lang-lisp">(defun expand-sub-dirs (path-name)
  &quot;Expand all the path segments in `PATH-NAME` to a list of sub-directories.&quot;
  (let* ((path-name (string-trim &#39;(#\/) (or path-name &quot;&quot;))))
    (if (empty? path-name)
      (return-from expand-sub-dirs &#39;()))
    (loop :for c :across path-name
          :for i :from 0
          :when (char= #\/ c)
          :collect (subseq path-name 0 i) :into lst
          :finally (return (append lst (list path-name))))))
</code></pre>
<h3 id="error-pages">Error pages</h3>
<pre><code class="lang-lisp">(defun page-error-not-found ()
  &quot;Not found error page.&quot;
  (set-http-code +http-not-found+)
  (page-template
    &quot;Not Found&quot;
    &quot;not-found-page&quot;
    (markup
      (:h2 &quot;Not Found&quot;)
      (:p &quot;The page or resource you requested could not be found.&quot;)
      (:p
        (:a :href &quot;/&quot;
         (:i :class &quot;fa fa-home&quot; &quot;&quot;)
         (:b &quot; Go back to the home page&quot;))))))

(defmethod acceptor-status-message (acceptor (http-status-code (eql 404)) &amp;key)
  (page-error-not-found))

(defun page-error-not-authorised ()
  &quot;Not authorised error page.&quot;
  (set-http-code +http-forbidden+)
  (page-template
    &quot;Not Authorised&quot;
    &quot;not-authorised-page&quot;
    (markup
      (:h2 &quot;Not Authorised&quot;)
      (:p &quot;Sorry, you don&#39;t have permission to view this page or resource.&quot;)
      (:p
        (:a :href &quot;/&quot;
         (:i :class &quot;fa fa-home&quot; &quot;&quot;)
         (:b &quot; Go back to the home page&quot;))))))

(defun page-error-server ()
  &quot;Internal server error page.&quot;
  (set-http-code +http-internal-server-error+)
  (page-template
    &quot;Server Error&quot;
    &quot;server-error-page&quot;
    (markup
      (:h2 &quot;Server Error&quot;)
      (:p (sf &#39;(&quot;Sorry, it looks like something went wrong on the server. &quot;
                &quot;Please try again later if the problem persists.&quot;)))
      (:p
        (:a :href &quot;/&quot;
         (:i :class &quot;fa fa-home&quot; &quot;&quot;)
         (:b &quot; Go back to the home page&quot;))))))

(defmethod acceptor-status-message (acceptor (http-status-code (eql 500)) &amp;key)
  (page-error-server))
</code></pre>
<h3 id="-page-about-"><code>PAGE-ABOUT</code></h3>
<pre><code class="lang-lisp">(defun page-about ()
  &quot;About page.&quot;
  (page-template
    &quot;About&quot;
    &quot;about-page&quot;
    (markup
      (:h2 &quot;About Fileworthy&quot;)
      (:p (sf &#39;(&quot;Fileworthy aims to be a simple solution to managing your &quot;
                &quot;notes and files across many devices. It is half static site &quot;
                &quot;generator, half file-system.&quot;)))
      (:table :class &quot;simple-table&quot;
       (:tr
         (:td &quot;Version&quot;)
         (:td (app-version *app*)))
       (:tr
         (:td &quot;Last Updated&quot;)
         (:td (pretty-time (app-last-updated *app*))))
       (:tr
         (:td &quot;Source Code&quot;)
         (:td (:a :href &quot;https://github.com/thiru/fileworthy&quot;
               &quot;Hosted at Github&quot;)))
       (:tr
         (:td &quot;License&quot;)
         (:td
           (:a :href &quot;https://www.gnu.org/licenses/gpl-3.0.html&quot; &quot;GPL v3&quot;)))
       (:tr
         (:td &quot;Copyright&quot;)
         (:td &quot;2017 Thirushanth Thirunavukarasu&quot;))))))
</code></pre>
<h3 id="-page-settings-"><code>PAGE-SETTINGS</code></h3>
<pre><code class="lang-lisp">(defun page-settings ()
  &quot;App settings page.&quot;
  (let* ((curr-user (session-value &#39;user)))
    ;; Only admins can view this page
    (if (or (null curr-user)
            (not (user-admin? curr-user)))
      (return-from page-settings (page-error-not-authorised)))
    (page-template
      &quot;Settings&quot;
      &quot;settings-page&quot;
      (markup
        (:h2 &quot;Settings&quot;)
        (:ul :id &quot;inputs&quot; :class &quot;flat-list&quot;
         (:li
           (:label
             (:span &quot;Site Name&quot;)
             (:input :id &quot;site-name&quot; :value (config-site-name *config*))
             (:div :class &quot;clear-fix&quot;)))
         (:li
           (:label
             (:span &quot;Root Directory&quot;)
             (:input :id &quot;root-dir&quot; :value (config-root-dir *config*))
             (:div :class &quot;clear-fix&quot;)))
         (:li
           (:label
             (:span &quot;Port&quot;)
             (:input :id &quot;port&quot; :value (to-string (config-port *config*)))
             (:div :class &quot;clear-fix&quot;)))
         (:li
           (:label
             (:span &quot;Allow anonymous read access&quot;)
             (if (config-allow-anonymous-read *config*)
               (raw
                 (markup
                   (:input :id &quot;anon-read&quot; :checked &quot;&quot; :type &quot;checkbox&quot;)))
               (raw
                 (markup
                   (:input :id &quot;anon-read&quot; :type &quot;checkbox&quot;))))
             (:div :class &quot;clear-fix&quot;)))
         (:li
           (:label
             (:span &quot;Reserved Resource Path&quot;)
             (:input
               :id &quot;rrp&quot;
               :value (config-reserved-resource-path *config*))
             (:div :class &quot;clear-fix&quot;))))
        (:div :id &quot;save-result&quot; &quot;&quot;)
        (:button
          :id &quot;save-btn&quot;
          :class &quot;button full-width&quot;
          :onclick &quot;page.save()&quot;
          &quot;Save&quot;)))))
</code></pre>
<h3 id="-api-settings-save-"><code>API-SETTINGS-SAVE</code></h3>
<pre><code class="lang-lisp">(defun api-settings-save ()
  &quot;Settings save API.&quot;
  (setf (content-type*) &quot;application/json&quot;)
  (let* ((curr-user (empty &#39;user :unless (session-value &#39;user)))
         (site-name (post-parameter &quot;siteName&quot;))
         (root-dir (post-parameter &quot;rootDir&quot;))
         (port (loose-parse-int (post-parameter &quot;port&quot;)))
         (port-changed? (/= port (config-port *config*)))
         (anon-read? (parse-js-bool (post-parameter &quot;anonRead&quot;)))
         (rrp (post-parameter &quot;rrp&quot;))
         (rrp-changed? (not (string= rrp
                                     (config-reserved-resource-path *config*))))
         (save-res (new-r :error &quot;Settings save unexpectedly aborted.&quot;)))

    ;; Validation
    (if (or (empty? curr-user)
            (not (user-admin? curr-user))) 
      (return-from api-settings-save (json-error +http-forbidden+)))
    (if (not (plusp port))
      (return-from
        api-settings-save
        (json-result (new-r :error &quot;Port must be a positive integer.&quot;))))
    (if (blank? rrp)
      (return-from
        api-settings-save
        (json-result (new-r :error &quot;Reserved Resource Path is required.&quot;))))

    ;; Persist
    (setf save-res
          (save-config
            (位 ()
               (setf (config-site-name *config*) site-name)
               (setf (config-root-dir *config*) root-dir)
               (setf (config-port *config*) port)
               (setf (config-allow-anonymous-read *config*) anon-read?)
               (setf (config-reserved-resource-path *config*) rrp))))

    ;; Return success/failure
    (if (succeeded? save-res)
      (progn
        (setf *config* (load-config (app-config-file-path *app*)))
        (if rrp-changed?
          (define-routes))
        ;; TODO: automatically reset if the port changed
        (if port-changed?
          (json-result
            (new-r :success (sf &#39;(&quot;Config updated. Please restart the app to &quot;
                                  &quot;use the new port.&quot;))))
          (json-result save-res)))
      (json-result save-res))))
</code></pre>
<h3 id="-page-user-list-"><code>PAGE-USER-LIST</code></h3>
<pre><code class="lang-lisp">(defun page-user-list ()
  &quot;User listing page.&quot;
  (let* ((curr-user (session-value &#39;user)))
    ;; Only admins can view this page
    (if (or (null curr-user)
            (not (user-admin? curr-user)))
      (return-from page-user-list (page-error-not-authorised)))
    (page-template
      &quot;Users&quot;
      &quot;user-list-page&quot;
      (markup
        (:a
          :id &quot;new-user-btn&quot;
          :class &quot;button&quot;
          :href (url-for (empty &#39;user))
          &quot;New User&quot;)
        (:ul :class &quot;big-list&quot;
          (loop
            :for user :in (config-users *config*)
            :collect
            (markup
              (:li
                (:a
                  :href (url-for user)
                  (user-name user))))))))))
</code></pre>
<h3 id="-page-user-detail-"><code>PAGE-USER-DETAIL</code></h3>
<pre><code class="lang-lisp">(defun page-user-detail ()
  &quot;User details page.&quot;
  (let* ((curr-user (empty &#39;user :unless (session-value &#39;user)))
         (path-segs (split-sequence #\/ (script-name*) :remove-empty-subseqs t))
         (user-id-str (nth 2 path-segs))
         (new-user? (string-equal &quot;new&quot; user-id-str))
         (req-user (empty
                     &#39;user
                     :unless (get-user :id (loose-parse-int user-id-str)))))
    ;; Redirect to Not Found page if user not found
    (if (and (not new-user?) (empty? req-user))
      (return-from page-user-detail (page-error-not-found)))
    ;; Redirect to Forbidden page if not admin and not current user
    (if (and (not (user-admin? curr-user))
             (not (eq curr-user req-user)))
      (return-from page-user-detail (page-error-not-authorised)))
    (page-template
      (if new-user? &quot;New User&quot; (user-name req-user))
      &quot;user-detail-page&quot;
      (markup
        (:h2
          :id &quot;name-heading&quot;
          :data-user-id (to-string (user-id req-user))
         (if new-user? &quot;New User&quot; (user-name req-user)))
        (:div :id &quot;input-fields&quot;
         (:input
           :id &quot;user-name&quot;
           :placeholder &quot;Name&quot;
           :title &quot;Name&quot;
           :type &quot;text&quot;
           :value (user-name req-user))
         (:input
           :id &quot;email-address&quot;
           :placeholder &quot;Email Address&quot;
           :title &quot;Email Address&quot;
           :type &quot;email&quot;
           :value (user-email req-user))
         (if (user-admin? curr-user)
           (raw
             (markup
               (:label
                 (if (user-admin? req-user)
                   (raw
                     (markup
                       (:input :id &quot;is-admin&quot; :checked &quot;&quot; :type &quot;checkbox&quot;)))
                   (raw
                     (markup
                       (:input :id &quot;is-admin&quot; :type &quot;checkbox&quot;))))
                 &quot; Administrator&quot;))))
         (:div
           :class (if new-user? &quot;hidden&quot; &quot;&quot;)
           (:a
             :id &quot;show-pwds-btn&quot;
             :class &quot;button&quot;
             :href &quot;javascript:page.toggleChangePwd()&quot;
             &quot;Change Password&quot;)
           (:a
             :id &quot;hide-pwds-btn&quot;
             :class &quot;button hidden&quot;
             :href &quot;javascript:page.toggleChangePwd()&quot;
             &quot;Don&#39;t Change Password&quot;))
         (:div
           :id &quot;password-fields&quot;
           :class (if new-user? &quot;&quot; &quot;hidden&quot;)
           (:input
             :id &quot;current-pwd&quot;
             :class (if new-user? &quot;hidden&quot; &quot;&quot;)
             :placeholder &quot;Current Password&quot;
             :title &quot;Current Password&quot;
             :type &quot;password&quot;)
           (:input
             :id &quot;new-pwd&quot;
             :placeholder &quot;New Password&quot;
             :title &quot;New Password&quot;
             :type &quot;password&quot;)
           (:input
             :id &quot;new-pwd-confirm&quot;
             :placeholder &quot;Confirm New Password&quot;
             :title &quot;Confirm New Password&quot;
             :type &quot;password&quot;)))
        (:p :id &quot;save-result&quot; &quot;&quot;)
        (:a
          :id &quot;save-btn&quot;
          :class &quot;button full-width&quot;
          :href &quot;javascript:page.save()&quot;
          &quot;Save&quot;)))))
</code></pre>
<h3 id="-api-user-save-"><code>API-USER-SAVE</code></h3>
<pre><code class="lang-lisp">(defun api-user-save ()
  &quot;User save API.&quot;
  (setf (content-type*) &quot;application/json&quot;)
  (let* ((curr-user (empty &#39;user :unless (session-value &#39;user)))
         (path-segs (split-sequence #\/ (script-name*) :remove-empty-subseqs t))
         (id (loose-parse-int (nth 3 path-segs)))
         (new-user? (zerop id))
         (req-user (empty &#39;user :unless (get-user :id id)))
         (name (post-parameter &quot;name&quot;))
         (email (post-parameter &quot;email&quot;))
         (admin? (and (user-admin? curr-user)
                      (parse-js-bool (post-parameter &quot;isAdmin&quot;))))
         (current-pwd (post-parameter &quot;currentPwd&quot;))
         (new-pwd (post-parameter &quot;newPwd&quot;))
         (save-res (new-r :error &quot;User save unexpectedly aborted.&quot;)))

    ;; Validation
    (if (empty? curr-user)
      (return-from api-user-save (json-error +http-forbidden+)))
    (if (and (not new-user?) (empty? req-user))
      (return-from
        api-user-save
        (json-result (new-r :error &quot;User with id ~A not found.&quot; id))))
    ;; Non-admins cannot change another user&#39;s password
    (if (and (not new-user?)
             (not (user-admin? curr-user))
             (/= (user-id curr-user) (user-id req-user)))
      (return-from
        api-user-save
        (json-error +http-forbidden+)))
    (if (empty? name)
      (return-from
        api-user-save
        (json-result (new-r :error &quot;No user name provided.&quot;))))
    (if (empty? email)
      (return-from
        api-user-save
        (json-result (new-r :error &quot;No email address provided.&quot;))))
    (if (and (empty? new-pwd)
             (or new-user?
                 (and (not new-user?) (not (empty? current-pwd)))))
      (return-from
        api-user-save
        (json-result (new-r :error &quot;No password provided.&quot;))))
    (if (and (blank? new-pwd)
             (or new-user?
                 (and (not new-user?) (not (empty? current-pwd)))))
      (return-from
        api-user-save
        (json-result (new-r :error &quot;Password can&#39;t be blank.&quot;))))
    (if (and (&gt; (app-min-password-length *app*) (length new-pwd))
             (or new-user?
                 (and (not new-user?) (not (empty? current-pwd)))))
      (return-from
        api-user-save
        (json-result
          (new-r :error
                 (sf &quot;Password must be at least ~A characters.&quot;
                     (app-min-password-length *app*))))))
    (if (and (not new-user?)
             (not (user-admin? curr-user))
             (not (authenticate-user req-user current-pwd)))
      (return-from
        api-user-save
        (json-result
          (new-r :error &quot;Current password is incorrect.&quot;))))

    ;; Persist
    (setf save-res
          (save-config
            (位 ()
               (let* ((curr-config *config*)
                      (salt (random-string)))
                 (if new-user?
                   (progn
                     (push
                       (make-user
                         :id (config-next-user-id curr-config)
                         :name name
                         :email email
                         :admin? admin?
                         :salt salt
                         :password (gen-hash new-pwd salt))
                       (config-users curr-config))
                     (incf (config-next-user-id curr-config)))
                   (progn
                     (setf (user-name req-user) name)
                     (setf (user-email req-user) email)
                     (setf (user-admin? req-user) admin?)
                     (when (not (empty? new-pwd))
                       (setf (user-salt req-user) salt)
                       (setf (user-password req-user)
                             (gen-hash new-pwd salt)))))))))

    (if (failed? save-res)
      (return-from api-user-save (json-result save-res)))

    ;; If the password changed for an existing user, remove all session
    ;; objects for the user, except the current session
    (when (and (not new-user?)
               (not (empty? new-pwd)))
      (hunchentoot::with-session-lock-held
        ((session-db-lock *acceptor*))
        (setf (session-db *acceptor*)
              (loop :for (k . v) in (session-db *acceptor*)
                    :when (or (= (session-id v)
                                 (session-id *session*))
                              (/= (user-id req-user)
                                  (user-id (session-value &#39;user v))))
                    :collect (cons k v)))))

    ;; Return success
    (json-result (new-r :success
                        (if new-user?
                          (sf &quot;Saved new user, ~A.&quot; name)
                          (sf &quot;Updated ~A&#39;s account.&quot; name))))))
</code></pre>
<h3 id="-api-login-"><code>API-LOGIN</code></h3>
<pre><code class="lang-lisp">(defun api-login ()
  &quot;User login API.&quot;
  (setf (content-type*) &quot;application/json&quot;)
  (let* ((email (post-parameter &quot;email&quot;))
         (pwd (post-parameter &quot;pwd&quot;))
         (user (get-user :email email)))
    (if (empty? email)
      (return-from
        api-login
        (json-result (new-r :error &quot;No email address provided.&quot;))))
    (if (empty? pwd)
      (return-from
        api-login
        (json-result (new-r :error &quot;No password provided.&quot;))))
    (when (not (authenticate-user user pwd))
      (sleep 2)
      (return-from
        api-login
        (json-result (new-r :error &quot;Incorrect credentials.&quot;))))

    ;; Create session for user
    (setf (session-value &#39;user) user)

    (json-result (new-r :success (sf &quot;Welcome ~A.&quot; (user-name user))))))
</code></pre>
<h3 id="-page-logout-"><code>PAGE-LOGOUT</code></h3>
<pre><code class="lang-lisp">(defun page-logout ()
  (when *session*
    (delete-session-value &#39;user)
    (remove-session *session*))
  (page-template
    &quot;Logout&quot;
    &quot;logout-page&quot;
    (markup
    (:h2 &quot;Thank you, come again!&quot;)
    (:p
     (:a :class &quot;full-width&quot;
         :href &quot;/&quot;
         &quot;Go back to Home page&quot;)))))
</code></pre>
<h3 id="-page-fs-path-"><code>PAGE-FS-PATH</code></h3>
<ul>
<li>This page displays a file-system path<ul>
<li>i.e. a directory or file</li>
</ul>
</li>
<li>If the file appears to be a binary file, don&#39;t show it but provide links with options</li>
<li>If the path is a directory with one non-binary file in it, just show it</li>
</ul>
<pre><code class="lang-lisp">(defun page-fs-path ()
  &quot;File-system path page.&quot;
  (let* ((user (empty &#39;user :unless (session-value &#39;user)))
         (path-name (script-name* *request*))
         (path-segs (split-sequence #\/ path-name :remove-empty-subseqs t))
         (abs-fs-path (empty &#39;string :unless (get-fs-path-from-url path-name)))
         (dir-exists? (if (not (empty? abs-fs-path))
                        (directory-exists-p abs-fs-path)))
         (file-exists? (if (and (not dir-exists?)
                                (not (empty? abs-fs-path)))
                         (file-exists-p abs-fs-path)))
         (binary-file? (if file-exists? (is-file-binary? abs-fs-path)))
         (curr-file-name &quot;&quot;)
         (rel-fs-path (if abs-fs-path
                        (subpathp abs-fs-path
                                  (config-root-dir *config*))))
         (file-content &quot;&quot;)
         (file-names (get-file-names abs-fs-path)))
    ;; Check anonymous access
    (if (and (empty? user)
             (not (config-allow-anonymous-read *config*)))
      (return-from page-fs-path (page-error-not-authorised)))
    ;; Show 404 page if dir/file not found
    (if (and (null dir-exists?) (null file-exists?))
      (return-from page-fs-path (page-error-not-found)))
    ;; Download file
    (if (and file-exists?
             (or binary-file? (get-parameter &quot;download&quot;)))
      (return-from page-fs-path (handle-static-file abs-fs-path)))
    ;; File requested
    (when file-exists?
      (setf curr-file-name (last1 path-segs))
      (when (or (not binary-file?) (get-parameter &quot;force-show&quot;))
        (setf file-content (get-file-content abs-fs-path))))
    ;; Directory requested, but only one file in dir so show it
    (when (and dir-exists? (= 1 (length file-names)))
      (setf abs-fs-path (concatenate &#39;string
                                     (to-string abs-fs-path)
                                     (first file-names)))
      (setf curr-file-name (first file-names))
      (when (or (not binary-file?) (get-parameter &quot;force-show&quot;))
        (setf file-content (get-file-content abs-fs-path))))
    (page-template
      (if (empty? rel-fs-path) &quot;Home&quot; rel-fs-path)
      &quot;fs-path-page&quot;
      (markup
        (:table :id &quot;files&quot; :class &quot;file-names&quot;
         (:tbody
          (loop
           :for file-name :in file-names
           :collect
           (markup
             (:tr
               :class
               (if (string= file-name curr-file-name)
                 &quot;selected&quot;
                 nil)
               (:td
                 (:a :href file-name file-name))
               (:td
                 (:a
                   :class &quot;download&quot;
                   :href (sf &quot;~A?download&quot; file-name)
                   :title &quot;Download file&quot;
                   (:i :class &quot;fa fa-download&quot; &quot;&quot;))))))))
        (:p :id &quot;path-trail&quot;
          (:i
            :class
            (if dir-exists?
              &quot;fa fa-folder-open&quot;
              &quot;fa fa-file&quot;)
            &quot;&quot;)
          (:span &quot; &quot;)
          (:span (if (empty? rel-fs-path)
                   &quot;/&quot;
                   (to-string rel-fs-path))))
        (:section :id &quot;file-details&quot;
         (if (or (not binary-file?) (get-parameter &quot;force-show&quot;))
           (raw (markup
                  (:pre
                    (:code :id &quot;raw-file-content&quot; :class &quot;hidden&quot; file-content))
                  (:div :id &quot;gen-file-content&quot;)))
           (raw
             (markup
               (:p &quot;It looks like this is a binary file, so it isn&#39;t displayed.&quot;)
               (:p
                 &quot;You can &quot;
                 (:a
                   :href (sf &quot;~A?download&quot; curr-file-name)
                   &quot;download the file&quot;)
                 &quot; or try to &quot;
                 (:a
                   :href (sf &quot;~A?force-show&quot; curr-file-name)
                   &quot;display it anyway.&quot;))))))))))

(defun get-fs-path-from-url (path-name)
  &quot;Gets an absolute local file-system path from the given path name.&quot;
  (concatenate &#39;string (config-root-dir *config*)
               (string-left-trim &#39;(#\/) path-name)))
</code></pre>
      </body></html>